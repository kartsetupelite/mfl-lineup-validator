<!DOCTYPE html>
<html>
<head>
  <title>MFL Lineup Validator</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f8f9fa; margin: 20px; }
    #debugPanel { background: #222; color: #0f0; padding: 15px; border-radius: 5px; margin: 24px 0; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; }
    .debug-controls { margin-bottom: 8px; }
    .debug-controls button { padding: 4px 12px; margin-right: 6px; font-size: 12px; cursor: pointer; }
    .settings-box { background: #fff; border: 1px solid #ddd; padding: 15px; border-radius: 5px; max-width: 650px; margin: 20px auto; }
    label { display: block; margin-top: 12px; font-weight: bold; }
    input, select { padding: 7px; margin-top: 4px; border-radius: 4px; border: 1px solid #ccc; width: 100%; box-sizing: border-box; }
    button#runBtn { padding: 10px 22px; background: #2196F3; color: white; border-radius: 4px; border: none; cursor: pointer; margin: 16px 0; }
    #report { margin-top: 20px; }
    table { width: 100%; border-collapse: collapse; margin-top: 12px; }
    th, td { border: 1px solid #bbb; padding: 8px 10px; text-align: center; }
    th { background: #f0f0f0; }
    .status-valid  { color: #28a745; font-weight: bold; }
    .status-invalid { color: #d9303e; font-weight: bold; }
    .status-nolineup { color: #d9303e; font-weight: bold; }
    .status-partial { color: #e67e00; font-weight: bold; }
    .status-reasons { font-size: 12px; font-weight: normal; color: #d9303e; margin-top: 3px; }
    .status-messages { font-size: 12px; font-weight: normal; color: #e67e00; margin-top: 3px; }
    /* Clickable status badge */
    .status-badge {
      cursor: pointer;
      text-decoration: underline dotted;
      user-select: none;
    }
    .status-badge:hover { opacity: 0.8; }
    /* Expandable detail row */
    .detail-row { display: none; }
    .detail-row.expanded { display: table-row; }
    .detail-row td {
      background: #f0f7ff;
      padding: 0;
      border-top: none;
    }
    .detail-inner {
      padding: 10px 16px;
      text-align: left;
    }
    .detail-inner table {
      margin-top: 6px;
      font-size: 13px;
      width: auto;
      min-width: 400px;
    }
    .detail-inner th { background: #dce9f8; font-size: 12px; padding: 5px 10px; }
    .detail-inner td { padding: 4px 10px; border: 1px solid #c8d8ee; background: #fff; }
    .detail-inner tr:nth-child(even) td { background: #f5f9ff; }
    .player-starter { color: #28a745; }
    .player-nonstarter { color: #888; }
    .detail-inner .violationRow td { background: #fff5f5; border-top: 2px solid #d9303e; border-bottom: 2px solid #d9303e; }
    .detail-inner .violationRow td:first-child { border-left: 2px solid #d9303e; }
    .detail-inner .violationRow td:last-child { border-right: 2px solid #d9303e; }
    .no-lineup-msg { color: #888; font-style: italic; padding: 6px 0; }
    .team-cell { text-align: left; white-space: nowrap; }
    .team-logo { width: 36px; height: 36px; object-fit: contain; vertical-align: middle; margin-right: 8px; border-radius: 3px; }
  </style>
</head>
<body>
  <div style="max-width: 900px; margin: auto;">
    <h2>MFL Lineup Validator</h2>
    <div class="settings-box">
      <label>League ID: <input type="text" id="leagueInput" value="17011"></label>
      <label>Year: <input type="text" id="yearInput" value="2025"></label>
      <label>Server: <input type="text" id="serverInput" value="www48"></label>
      <label>Week: <select id="weekSelect"></select></label>
      <label>CORS Proxy URL: <input type="text" id="proxyInput"></label>
      <button id="runBtn">Run Report</button>
    </div>
    <div class="debug-controls">
      <button id="toggleDebug">Hide Debug</button>
      <button id="clearDebug">Clear Debug</button>
    </div>
    <div id="debugPanel">Debug console ready...</div>
    <div id="report"></div>
  </div>
  <script>
    document.getElementById('proxyInput').value = 'https://mfl-proxy-worker.kartsetupelite.workers.dev/';

    // Debug panel toggle/clear
    document.getElementById('toggleDebug').onclick = function() {
      var panel = document.getElementById('debugPanel');
      var btn = document.getElementById('toggleDebug');
      if (panel.style.display === 'none') {
        panel.style.display = '';
        btn.textContent = 'Hide Debug';
      } else {
        panel.style.display = 'none';
        btn.textContent = 'Show Debug';
      }
    };
    document.getElementById('clearDebug').onclick = function() {
      document.getElementById('debugPanel').innerHTML = '';
    };

    function escHtml(str) {
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    }

    function dbg(msg, data, type) {
      var panel = document.getElementById('debugPanel');
      var color = '#0f0';
      if (type === 'error') color = '#ff6b6b';
      if (type === 'info')  color = '#74c0fc';
      if (type === 'warn')  color = '#ffd43b';
      var ts = new Date().toLocaleTimeString();
      var text = '[' + ts + '] ' + escHtml(String(msg));
      if (data !== undefined) {
        try { text += ' ' + escHtml(JSON.stringify(data, null, 2)); } catch(e) { text += ' [unserializable]'; }
      }
      panel.innerHTML += '<div style="color:' + color + '">' + text + '</div>';
      panel.scrollTop = panel.scrollHeight;
      if (data !== undefined) console.log(msg, data); else console.log(msg);
    }

    // Normalise MFL API values that may be array, object, or missing
    function toArray(val) {
      if (!val) return [];
      return Array.isArray(val) ? val : [val];
    }

    function getProxyBase() {
      var raw = document.getElementById('proxyInput').value.trim();
      return raw.endsWith('/') ? raw : raw + '/';
    }

    async function proxyFetch(url) {
      var proxyBase = getProxyBase();
      var proxied = proxyBase + '?url=' + encodeURIComponent(url);
      dbg('Fetching: ' + url, undefined, 'info');
      var resp = await fetch(proxied);
      if (!resp.ok) {
        var preview = (await resp.text()).substring(0, 200);
        throw new Error('HTTP ' + resp.status + ' from proxy: ' + preview);
      }
      return resp.json();
    }

    function getMFLApiUrl(server, year, params) {
      return 'https://' + server + '.myfantasyleague.com/' + year + '/export?' + params + '&JSON=1';
    }

    // Event delegation: toggle expand/collapse when a status badge is clicked
    document.getElementById('report').addEventListener('click', function(e) {
      var badge = e.target.closest('.status-badge');
      if (!badge) return;
      var fid = badge.getAttribute('data-fid');
      if (!fid) return;
      var detailRow = document.getElementById('detail-' + fid);
      if (!detailRow) return;
      if (detailRow.classList.contains('expanded')) {
        detailRow.classList.remove('expanded');
      } else {
        detailRow.classList.add('expanded');
      }
    });

    // ── Player database (module-level, fetched on validator load) ────────────
    var playerNameMap = {};
    var playerPosMap  = {};
    var _loadedPlayerKey = null; // "server|year|league" key for cache invalidation

    async function loadPlayers(server, year, league) {
      var key = JSON.stringify([server, year, league]);
      if (_loadedPlayerKey === key) {
        dbg('Player data already loaded for current settings, using cached.', undefined, 'info');
        return;
      }
      playerNameMap = {};
      playerPosMap  = {};
      _loadedPlayerKey = null;
      try {
        var playersUrl = getMFLApiUrl(server, year, 'TYPE=players&L=' + league + '&DETAILS=1');
        var playersData = await proxyFetch(playersUrl);
        dbg('Raw players API response (first 3):', toArray(playersData && playersData.players && playersData.players.player).slice(0, 3));
        toArray(playersData && playersData.players && playersData.players.player).forEach(function(p) {
          if (p && p.id) {
            playerNameMap[p.id] = p.name || '';
            playerPosMap[p.id]  = p.position || '';
          }
        });
        _loadedPlayerKey = key;
        dbg('Player name map loaded: ' + Object.keys(playerNameMap).length + ' players', undefined, 'info');
      } catch (playerErr) {
        dbg('Could not load player names (non-fatal): ' + playerErr.message, undefined, 'warn');
      }
    }

    // Fetch players immediately on validator load using the current form values
    (async function() {
      var server = document.getElementById('serverInput').value.trim();
      var year   = document.getElementById('yearInput').value.trim();
      var league = document.getElementById('leagueInput').value.trim();
      if (server && year && league) {
        await loadPlayers(server, year, league);
      }
    })().catch(function(err) {
      dbg('Error during initial player load: ' + err.message, undefined, 'error');
    });

    // ── Lineup validation constants ──────────────────────────────────────────
    var POS_MIN = { QB: 1, RB: 2, WR: 3, TE: 1, PK: 1, DT: 1, DE: 2, LB: 2, CB: 3, S: 2 };
    var POS_MAX = { QB: 1, RB: 3, WR: 4, TE: 2, PK: 1, DT: 3, DE: 5, LB: 5, CB: 4, S: 3 };
    var OFFENSE_POSITIONS = ['QB', 'RB', 'WR', 'TE', 'PK'];
    var IDP_POSITIONS     = ['DT', 'DE', 'LB', 'CB', 'S'];
    var MAX_STARTERS      = 22;
    var OFFENSE_MAX       = 9;
    var IDP_MAX           = 13;

    // Returns { status, reasons, messages }
    // status: 'no-lineup' | 'invalid' | 'partial' | 'valid'
    // reasons: array of strings explaining why invalid
    // messages: array of informational strings for partial
    function validateLineup(starterPlayers) {
      var total = starterPlayers.length;
      if (total === 0) {
        return { status: 'no-lineup', reasons: [], messages: [] };
      }

      var posCounts = {};
      var offenseCount = 0;
      var idpCount = 0;
      starterPlayers.forEach(function(p) {
        var pos = p.position || '';
        posCounts[pos] = (posCounts[pos] || 0) + 1;
        if (OFFENSE_POSITIONS.indexOf(pos) !== -1) offenseCount++;
        if (IDP_POSITIONS.indexOf(pos) !== -1) idpCount++;
      });

      // Check hard-rule violations
      var reasons = [];
      if (total > MAX_STARTERS) {
        reasons.push('Too many total starters: ' + total + ' (max ' + MAX_STARTERS + ')');
      }
      if (offenseCount > OFFENSE_MAX) {
        reasons.push('Too many offense starters: ' + offenseCount + ' (max ' + OFFENSE_MAX + ')');
      }
      if (idpCount > IDP_MAX) {
        reasons.push('Too many IDP starters: ' + idpCount + ' (max ' + IDP_MAX + ')');
      }
      Object.keys(POS_MAX).forEach(function(pos) {
        var cnt = posCounts[pos] || 0;
        if (cnt > POS_MAX[pos]) {
          reasons.push('Too many ' + pos + ' starters: ' + cnt + ' (max ' + POS_MAX[pos] + ')');
        }
      });
      if (reasons.length > 0) {
        return { status: 'invalid', reasons: reasons, messages: [] };
      }

      // Check for full valid lineup
      if (total === MAX_STARTERS && offenseCount === OFFENSE_MAX && idpCount === IDP_MAX) {
        var allMinsMet = Object.keys(POS_MIN).every(function(pos) {
          return (posCounts[pos] || 0) >= POS_MIN[pos];
        });
        if (allMinsMet) {
          return { status: 'valid', reasons: [], messages: [] };
        }
      }

      // Partial: 1–21 starters with no hard-rule violations
      if (total < MAX_STARTERS) {
        var messages = [];
        var needed = MAX_STARTERS - total;
        messages.push('Need ' + needed + ' more starter' + (needed !== 1 ? 's' : '') + ' to reach ' + MAX_STARTERS);
        Object.keys(POS_MIN).forEach(function(pos) {
          var shortage = POS_MIN[pos] - (posCounts[pos] || 0);
          if (shortage > 0) {
            messages.push('Need at least ' + shortage + ' more ' + pos + ' (min ' + POS_MIN[pos] + ')');
          }
        });
        return { status: 'partial', reasons: [], messages: messages };
      }

      // Exactly 22 starters but fails distribution or minimums → invalid
      var distReasons = [];
      if (offenseCount !== OFFENSE_MAX) {
        distReasons.push('Offense starters: ' + offenseCount + ' (need exactly ' + OFFENSE_MAX + ')');
      }
      if (idpCount !== IDP_MAX) {
        distReasons.push('IDP starters: ' + idpCount + ' (need exactly ' + IDP_MAX + ')');
      }
      Object.keys(POS_MIN).forEach(function(pos) {
        var shortage = POS_MIN[pos] - (posCounts[pos] || 0);
        if (shortage > 0) {
          distReasons.push('Not enough ' + pos + ' starters: ' + (posCounts[pos] || 0) + ' (min ' + POS_MIN[pos] + ')');
        }
      });
      return { status: 'invalid', reasons: distReasons, messages: [] };
    }

    // Returns a Set of player IDs that are involved in rule violations.
    // Only highlights "too many" violations (excess players), not "not enough" shortages.
    function getViolatingPlayerIds(starterPlayers) {
      var violating = new Set();
      var offensePlayers = [];
      var idpPlayers = [];
      var posByGroup = {};
      starterPlayers.forEach(function(p) {
        var pos = p.position || '';
        if (!posByGroup[pos]) posByGroup[pos] = [];
        posByGroup[pos].push(p.id);
        if (OFFENSE_POSITIONS.indexOf(pos) !== -1) offensePlayers.push(p.id);
        if (IDP_POSITIONS.indexOf(pos) !== -1) idpPlayers.push(p.id);
      });
      if (offensePlayers.length > OFFENSE_MAX) {
        offensePlayers.forEach(function(id) { violating.add(id); });
      }
      if (idpPlayers.length > IDP_MAX) {
        idpPlayers.forEach(function(id) { violating.add(id); });
      }
      Object.keys(POS_MAX).forEach(function(pos) {
        var ids = posByGroup[pos] || [];
        if (ids.length > POS_MAX[pos]) {
          ids.forEach(function(id) { violating.add(id); });
        }
      });
      return violating;
    }

    document.getElementById('runBtn').onclick = async function() {
      var league = document.getElementById('leagueInput').value.trim();
      var server = document.getElementById('serverInput').value.trim();
      var year   = document.getElementById('yearInput').value.trim();
      var week   = document.getElementById('weekSelect').value;
      var reportDiv = document.getElementById('report');
      reportDiv.innerHTML = '<p>Loading...</p>';
      dbg('=== Run Report clicked ===', undefined, 'info');
      dbg('Settings: league=' + league + ' server=' + server + ' year=' + year + ' week=' + week, undefined, 'info');
      try {
        // ── 1. Fetch league data ──────────────────────────────────────────────
        var leagueUrl = getMFLApiUrl(server, year, 'TYPE=league&L=' + league);
        var leagueData = await proxyFetch(leagueUrl);
        if (!leagueData || !leagueData.league) {
          throw new Error('Invalid league API response – missing leagueData.league');
        }
        dbg('League loaded: ' + (leagueData.league.name || '(unnamed)'), undefined, 'info');

        // Build team name and logo maps: franchise id -> name / logo URL
        var teamMap = {};
        var teamLogoMap = {};
        toArray((leagueData.league.franchises || {}).franchise).forEach(function(f) {
          teamMap[f.id] = f.name || f.id;
          teamLogoMap[f.id] = f.logo || '';
        });

        // Determine minimum starters – kept for debug logging only
        var minStarters = MAX_STARTERS;
        var req = leagueData.league.starters || leagueData.league.lineup_requirements;
        if (req) {
          var cnt = Number(req.count || req.total || 0);
          if (cnt > 0) minStarters = cnt;
        }
        dbg('Minimum starters required: ' + minStarters, undefined, 'info');

        // ── 1b. Load player name map (re-fetch only if settings changed) ──────
        await loadPlayers(server, year, league);

        // ── 2. Fetch liveScoring data ─────────────────────────────────────────
        var liveScoringUrl = getMFLApiUrl(server, year, 'TYPE=liveScoring&L=' + league + '&W=' + week + '&DETAILS=1');
        var liveScoringData = await proxyFetch(liveScoringUrl);
        dbg('Raw liveScoring API response:', liveScoringData);

        if (!liveScoringData || !liveScoringData.liveScoring) {
          throw new Error('liveScoring API response is missing or malformed');
        }

        // ── 3. Extract starter counts and player lists per franchise ──────────
        // liveScoring.matchup can be array or single object
        var matchups = toArray(liveScoringData.liveScoring.matchup);
        if (matchups.length === 0) {
          dbg('No matchups found in liveScoring response for week ' + week, undefined, 'warn');
        }

        // franchiseStarters: { franchiseId: starterCount }
        var franchiseStarters = {};
        // franchisePlayers: { franchiseId: [ { id, name, position, score, status } ] }
        var franchisePlayers = {};

        matchups.forEach(function(matchup) {
          // franchise can be array or single object
          var franchises = toArray(matchup.franchise);
          franchises.forEach(function(franchise) {
            var fid = franchise.id;
            if (!fid) {
              dbg('Franchise entry missing id, skipping', franchise, 'warn');
              return;
            }
            var count = 0;
            var players = [];
            if (franchise.players) {
              toArray(franchise.players.player).forEach(function(player) {
                if (player.status === 'starter') count++;
                if (player.id && !playerNameMap[player.id]) {
                  dbg('Player ID ' + player.id + ' not found in player mapping', undefined, 'warn');
                }
                players.push({
                  id:       player.id || '',
                  name:     playerNameMap[player.id] || '',
                  position: playerPosMap[player.id]  || '',
                  score:    player.score !== undefined ? player.score : '—',
                  status:   player.status || ''
                });
              });
            }
            franchiseStarters[fid] = count;
            franchisePlayers[fid]  = players;
          });
        });

        dbg('Computed franchise starter counts:', franchiseStarters);

        // ── 4. Build results table ────────────────────────────────────────────
        var teamsList = Object.keys(franchiseStarters);
        console.log('Teams List:', teamsList);
        teamsList.forEach(function(fid) {
          console.log('Processing Team:', fid, franchiseStarters[fid]);
        });

        if (teamsList.length === 0) {
          reportDiv.innerHTML = '<p><strong>No franchise data found for week ' + escHtml(week) + '.</strong> Lineups may not yet be submitted.</p>';
          dbg('No franchise data to display.', undefined, 'warn');
          return;
        }

        var POS_ORDER = ['QB','RB','WR','TE','PK','DT','DE','LB','CB','S'];
        var html = '<table>';
        html += '<tr><th>Team</th><th>Starters</th><th>Status (click to expand)</th></tr>';

        teamsList.sort().forEach(function(fid) {
          var count = franchiseStarters[fid];
          var name  = teamMap[fid] || fid;
          var logo  = teamLogoMap[fid] || '';

          // Build starter player list for validation
          var players = franchisePlayers[fid] || [];
          var starterPlayers = players.filter(function(p) { return p.status === 'starter'; })
            .sort(function(a, b) {
              var ai = POS_ORDER.indexOf(a.position);
              var bi = POS_ORDER.indexOf(b.position);
              if (ai === -1) ai = POS_ORDER.length;
              if (bi === -1) bi = POS_ORDER.length;
              return ai - bi;
            });

          var validation = validateLineup(starterPlayers);
          var statusClass, statusText;
          if (validation.status === 'no-lineup') {
            statusClass = 'status-nolineup';
            statusText  = 'No Lineup';
          } else if (validation.status === 'valid') {
            statusClass = 'status-valid';
            statusText  = 'Valid';
          } else if (validation.status === 'partial') {
            statusClass = 'status-partial';
            statusText  = 'Partial';
          } else {
            statusClass = 'status-invalid';
            statusText  = 'Invalid';
          }

          // Build sub-text for reasons (invalid) or messages (partial)
          var subHtml = '';
          if (validation.reasons.length > 0) {
            subHtml = '<div class="status-reasons">' + validation.reasons.map(escHtml).join('<br>') + '</div>';
          } else if (validation.messages.length > 0) {
            subHtml = '<div class="status-messages">' + validation.messages.map(escHtml).join('<br>') + '</div>';
          }

          // Team cell: logo (if present) + name
          var logoHtml = logo
            ? '<img class="team-logo" src="' + escHtml(logo) + '" alt="' + escHtml(name) + ' logo" onerror="this.style.display=\'none\'">'
            : '';
          var teamCell = '<td class="team-cell">' + logoHtml + escHtml(name) + '</td>';

          // Main team row with clickable status badge
          html += '<tr>'
            + teamCell
            + '<td>' + escHtml(String(count)) + '</td>'
            + '<td><span class="' + statusClass + ' status-badge" data-fid="' + escHtml(fid) + '" title="Click to show/hide lineup">' + escHtml(statusText) + ' ▾</span>' + subHtml + '</td>'
            + '</tr>';

          // Detail row (hidden by default)
          var detailContent;
          if (players.length === 0) {
            detailContent = '<div class="no-lineup-msg">No lineup submitted for this team.</div>';
          } else if (starterPlayers.length === 0) {
            detailContent = '<div class="no-lineup-msg">No starters found in lineup data.</div>';
          } else {
            var violatingIds = validation.status === 'invalid' ? getViolatingPlayerIds(starterPlayers) : new Set();
            var tbl = '<table>'
              + '<tr><th>Player ID</th><th>Name / Position</th><th>Score</th><th>Status</th></tr>';
            starterPlayers.forEach(function(p) {
              var namePos = p.name
                ? escHtml(p.name) + (p.position ? ' <em>(' + escHtml(p.position) + ')</em>' : '')
                : '<em style="color:#666">ID ' + escHtml(p.id) + '</em>';
              var statusCls = p.status === 'starter' ? 'player-starter' : 'player-nonstarter';
              var rowClassAttr = (p.id && violatingIds.has(p.id)) ? ' class="violationRow"' : '';
              tbl += '<tr' + rowClassAttr + '>'
                + '<td>' + escHtml(p.id || '—') + '</td>'
                + '<td>' + namePos + '</td>'
                + '<td>' + escHtml(String(p.score)) + '</td>'
                + '<td class="' + statusCls + '">' + escHtml(p.status) + '</td>'
                + '</tr>';
            });
            tbl += '</table>';
            detailContent = tbl;
          }

          html += '<tr id="detail-' + escHtml(fid) + '" class="detail-row">'
            + '<td colspan="3"><div class="detail-inner">'
            + '<strong>' + escHtml(name) + ' — Starting Lineup</strong>'
            + detailContent
            + '</div></td>'
            + '</tr>';
        });

        html += '</table>';
        reportDiv.innerHTML = html;
        dbg('Report rendered for ' + teamsList.length + ' franchises.', undefined, 'info');

      } catch (err) {
        dbg('Error: ' + err.message, undefined, 'error');
        console.error(err);
        reportDiv.innerHTML = '<p style="color:#d9303e"><strong>Failed to load data:</strong> ' + escHtml(err.message) + '</p>';
      }
    };

    // Populate week selector (weeks 1-17)
    var weekSel = document.getElementById('weekSelect');
    for (var i = 1; i <= 17; i++) {
      var opt = document.createElement('option');
      opt.value = i;
      opt.text = 'Week ' + i;
      weekSel.appendChild(opt);
    }
  </script>
</body>
</html>